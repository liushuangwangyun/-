# HTML5/CSS

## 1.Doctype作用？严格模式与混杂模式如何区分？它们有何意义？

### 作用：

   * doctype声明叫做文件类型定义（DTD），声明的作用是为了告诉浏览器该文件的类型。
   * <!DOCTYPE>声明位于文档中的最前面的位置，处于<html>标签之前，此标签可告知浏览器文档使用哪种HTML或XHTML规范
   * doctype不存在或者格式不正确会导致文档以混杂模式呈现

    （两种模式是浏览器解析CSS时的两种模式）
### 含义：
  * 标准模式（严格模式）是指：浏览器按W3C标准解析执行代码，严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行;
  * 怪异模式（兼容模式）则是指：使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样;页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为
     以防止站点无法工作
  * 区别：浏览器解析时到底使用严格模式还是混杂模式，与网页中的DTD直接相关
       1. 如果文档包含严格的DOCTYPE，那么他一般以严格模式呈现。
       2. 包含过渡DTD和ERL的DOCTYPE，也以严格模式呈现，但是有过渡DTD而没有URL（统一资源标识符，就是声明最后的地址）会导致页面呈现混杂模式
       3. DOCTYPE不存在或形式不正确会导致文档以混杂模式呈现
       4. HTML5没有DTD，因此也就没有严格模式与混杂模式的区别，HTML5有相对宽松的语法，实现时，已经尽可能大的实现僚向后兼容
  * 区别总结：
           1. 严格DTD--严格模式
           2. 有URLD的过渡TD--严格模式;没有URL的过渡DTD--混杂模式
           3. DTD不存在或者格式不正确--混杂模式
           4. HTML5没有严格和混杂之分
  * 意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么由于多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，
       每个浏览器都有自己的解析模式
### 补充：
  1. 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在IE5.5及以下的浏览器及其他版本的Quirks模式下，IE的宽度和高度还包含了padding和border。
  2. 可以设置行内元素的高宽
    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。
  3. 可设置百分比的高度
    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。
  4. 用margin:0 auto设置水平居中在IE下会失效
    使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,quirk模式下的解决办法，用text-align属性:
   body{text-align:center};#content{text-align:left}
  5. quirk模式下设置图片的padding会失效
  6. quirk模式下Table中的字体属性不能继承上层的设置
  7. quirk模式下white-space:pre会失效


## 2.HTML5为什么只需要写<!DOCTYPE HTML>?
  * html5不基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，
  * 所以需要进行DTD进行引用才能告知浏览器文档所使用的文档类型
### 补充：
  * XML:可扩展表示语言
  * SGML:通用标识语言
  * HTML:超文本标识语言

## 3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？
  * 行内元素：a-锚点  b-粗体  span-定义文本内区块  img-图片  input-输入框  strong-粗体强调  select-项目选择  label-表格标签  em-强调
           button-按钮  textarea-多行文本输入框  i-斜体  sub-下标  sup-上标  q-短引用
  * 块级元素：div  ul-非序列列表  li dl-定义列表  dt  dd  p-段落  h1-h6-标题  blockquote-标记长的引用  ol-序列表单  table-表格  fieldset-form-控制组  form-表单

  * 空(viod)元素:没有内容的单标签 br-换行  meta-模拟HTTP协议的响应头报文  hr-水平分割  link-当前文档引用外部文档  input img
  * 鲜为人知的是： <area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>
### 补充：
  * 块级元素特点：
  1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行
  2. 元素的高度、宽度、行高以及顶和底边距都可设置
  3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度
  * 行内元素特点：
  1. 和其他元素都在一行上
  2. 元素的高度、宽度、行高、以及顶部和底部边距不可设置
  3. 元素的宽度就是它包含的文字或图片的宽度，不可改变


## 4.页面导入样式时，使用link和@import有什么区别？
  * link:<link rel="stylesheet" rev="stylesheet" herf="css文件" type="text/css" media="all" />

    @import:<style type="text/css" media="screen">@import url("css文件")</style>
### 区别：
  1. link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事物;@import属于CSS范畴，只能加载CSS
  2. link引用CSS时，在页面载入时同时加载;@import需要页面网页完全载入以后加载
  3. link是标签XHTML标签，无兼容问题;@import是在CSS2.1提出的，低版本的浏览器不支持
  4. link支持使用javascript控制DOM去改变样式;而@import不支持
### 补充：
  @import url(style.css) 和@import url("style.css")是最优的选择，兼容的浏览器最多。从字节优化的角度来看@import url(style.css)最值得推荐。

## 5.介绍一下你对浏览器内核的理解？
  * 浏览器最重要或者核心的部分是渲染引擎，主要分成两个部分：渲染引擎和JS引擎
  * 渲染引擎：负责对网页语法的解释取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。

          浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程

          序都需要内核
  * JS引擎：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向与只指渲染引擎

## 6.常见的浏览器内核有哪些？
  1. 使用Trident的是internet explorer,国产的绝大部分浏览器。Trident就是ie内核
  2. 使用Gecko的是Mozilla Firefox,使用Gecko内核的浏览器也有不少，如Netscape MozillaSuite/SeaMonkey等
  3. 使用Presto的是opera,这是目前公认网页浏览速度最快的浏览器内核
  4. 使用WebKit的有苹果的safari,谷歌的chrome,还有国产的大部分双核浏览器其中一核就是WebKit

## 7.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？
  1. 新特性：

     h5现在已经不是SGML的子集，主要是关于图像、位置、存储、多任务等功能的增加

     拖拽释放（Drag and drop）API

     语义化更好的内容标签（header,nav,footor,aside,article,section）

     音频、视频API（audio,video）

     画布（Canvas）API

     地理（Geolocation）API

     本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失

     sessionStorage的数据在浏览器关闭后自动删除

     表单控件：calendar,date,time,email,url,search

     新的技术webworker,websocket,Geolocation

  2. 移除：
    纯表现的元素：basefont-规定页面上的默认字体大小, big-大号字体, center-水平居中, font-规定文本的字体、字体尺寸、字体颜色, s-加删除线,

    strike-加删除线, tt-定义打字机文本,u-定义下划线文本

    对可用性产生负面影响的元素：frame-定义框架级的窗口或框架, frameset-定义框架级, noframes-定义针对不支持框架的用户的替代内容
  3. 处理兼容问题：、

     IE8/IE7/IE6支持通过document.方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签

     使用HTML5shin框架
  4. 区分：

    doctype声明的方式是区别HTML和HTML5标志的一个重要因素，此外还可以根据新增的结构、功能元素加以区分

## 8.简述一下你对HTML语义化的理解？
### 简答：
       * 用正确的标签做正确的事情
       * html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
       * 即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的
       * 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;
       * 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解;
### 理解：
       * 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
### 写HTML应该注意什么：
       1. 尽可能少的使用无语义的标签div和span
       2. 在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利
       3. 不要使用纯样式标签，如：b  font  u等，改用css设置
       4. 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b）em是斜体（不用i）;
       5. 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td
       6. 表单域要用fieldset标签包起来，并用legend标签说明表单的用途
       7. 每个input标签对应的说明文本都需要使用lebel标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来

## 9.HTML5的离线储存怎么使用，工作原理能不能解释一下？
### 如何使用：
       1. 页面头部像下面一样加入一个manifest在（index.html里加上<html manifest="test.manifest">）;
       2. 在cache.manifest文件的编写离线存储的资源”
            ```
            CACHE MANIFEST
            #上面一句必须有
            #v0.11
            #需要缓存的文件
            CACHE:
            js/app.js
            css/style.css
            #不需要缓存的文件
            NETWORK:
            resourse/logo.png
            #无法访问页面
            FALLBACK:
            //offline.html
            ```
     3. 在离线状态时，操作window.applicationCache进行需求实现（manifest文件的mime-type必须是 text/cache-manifest类型。搜索）
### 工作原理：
     HTML5的离线存储是基于一个新建的.appcache文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储下来。

     之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示

## 10.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？
   在线的情况下，浏览器发现html头部有manifest属性，他会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线

   存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么、

   就会重新下载文件中的资源并重进行离线存储。

   离线的情况下，浏览器就直接使用离线存储的资源

## 11.请描述一下 cookies，sessionStorage 和 localStorage 的区别？
   * 共同点：都存储在客户端
   * 不同点：
 
          1. 存储大小
          cookle数据大小不能找过了4k
          sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可以达到5M或更大

          2. 有效时间
          localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;
          sessionStorage数据在当前浏览器窗口关闭后自动删除
          cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

          3. 数据与服务器之间的交互方式
          cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端
          sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
    
    
    
    
    
### 补充：
        * cookie的内容：采用 key=value;key=value……存储，参数名自定义
        * cookie的过期时间：使用参数expires
        * cookie的路径：使用参数path，"/"表示这个网站的页面，不推荐!容易产生冲突
        * 注意：形如“/pro/index.html”路径，在google浏览器正常，在IE浏览器得不到值

        cookie的表示方式示例
         
        
        
        
        [javascript]view plaincopy
        var name = "jack";
        var pwd = "123";
        var now = new Date();
        now.setTime(now.getTime() +1 * 24 * 60 * 60 * 1000);//转毫秒
        var path = "/";//可以是具体的网页
        document.cookie = "name=" + name + ";expires=" + now.toUTCString() + ";path=" + path;//姓名
        document.cookie= "pwd=" + pwd + ";expires=" + now.toUTCString()+ ";path=" + path; //密码

        读取cookie
        获取cookie内容
        [html]view plaincopy
        vardata=document.cookie;//获取对应页面的cookie

        解析cookie
        方式1：截取字符串
        [javascript]view plaincopy
        function getKey(key) {
        var data = document.cookie;
        var findStr = key + "=";
        //找到key的位置
        var index = data.indexOf(findStr);
        if (index == -1)
        return null;
        var subStr = data.substring(index +findStr.length);
        var lastIndex = subStr.indexOf(";");
        if (lastIndex == -1) {
        return subStr;
        } else {
        return subStr.substring(0,lastIndex);
        }
        }

        方式2：使用正则表达式+JSON
        [javascript]view plaincopy
        function getKey(key) {
        return JSON.parse("{\"" +document.cookie.replace(/;\s+/gim, "\",\"").replace(/=/gim, "\":\"") + "\"}")[key];
        }

        清除cookie
        [javascript]view plaincopy
        var name = null;
        var pwd = null;
        var now = new Date();
        var path = "/";//可以是具体的网页
        document.cookie= "name=" + name + ";expires=" + now.toUTCString()+ ";path=" + path;//姓名
        document.cookie = "pwd=" + pwd + ";expires=" + now.toUTCString()+ ";path=" + path; //密码
        
        
        
        
        
        
## 12.iframe有那些缺点？

   iframe是一种框架，也是一种很常见的网页嵌入方式

### 优点：
   1. iframe能够原封不动的把嵌入的网页展示出来
   2. 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷
   3. 网页如果为了同意风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用
   4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决
### 缺点：
   1. 会产生很多页面，不容易管理
   2. iframe框架结构有时会让人感到迷惑，如果框架个数多，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差
   3. 代码复杂，无法被一些搜索引擎引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化
   4. 很多的框架页面会增加服务器的http请求，对于大型网站是不可取的



## 13.Label的作用是什么？是怎么用的？（加 for 或 包裹）
   * 元素定义标注（标记）

     label元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在label元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，

     浏览器就会自动将焦点转到和标签相关的表单控件上。<label>标签的for属性应当与相关元素的id属性相同



## 14.HTML5的form如何关闭自动完成功能？

   <form autocomplete="on|off">

   有三种方法：

   1. 在IE的Internet选项菜单里的内容--自动完成里面设置
   2. 设置form的autocomplete为“on”或者“off”来开启或者关闭自动完成功能
   3. 设置输入框的autocomplete为"on"或者"off"来开启或者关闭该输入框的自动完成功能



## 15.如何实现浏览器内多个标签页之间的通信?
### 方法一：
         * 使用localStorage
         * 使用localStorage.setltem(key,value);添加内容
         * 使用storage事件监听、修改、删除的动作
         
```
    window.addEcentListener("storage",function(event){
      $("#name").val(event.key+"="+event.newValue);
      });
```

### 方法二：使用cookie + setlnterval

```
    <input id="name"><input type="button" id="btnOK" value="发送">

    $(function(){
      $("#btnOK").click(function(){
        var name = $("#name").val;
        document.cookie = "name = " + name;
        })
      })

    // 获取Cookkie天的内容
    function getKey(key){
      return JSON.parse("{\""+ document.cookie.replace(/;\s+/gim,"\",\"").replace(/=/gim, "\":\"") +"\"}")[key];  
    }

   //每隔着秒获取Cookkie的内容
   setltem(function(){
     console.log(getKey("name"));
     },1000);
```

## 16.webSocket如何兼容低浏览器？

引用WebSocket.js这个文件来兼容低版本浏览器，WebSocket.swf需 要放在与页面相同的目录下。

用法和正常的webSocket基本一样,只是引用了webSocket.js这个文件来兼容低版本浏览器.

## 17.页面可见性（Page Visibility API） 可以有哪些用途？
* 用途:当可见性发生了改变的时候，会触发 visibilityState事件，通过给事件注册一个监听函数，那么就可以进行一些操作：即能够在页面切

  换到不可见状态时暂停执行一些不必要的操作,以减少资源的浪费.

  比如当前页面在播放动画，检测到用户切换了或者最小化了该窗口，则自动停止；

  有的程序会及时刷新访问界面（比如篮球比赛时的比分更新），若窗口关闭，他也会停止刷新；

* 页面可见性:就是对于用户来说,页面是显示还是隐藏,所谓显示的页面,就是我们正在看的页面;隐藏的页面,就是我们没有看到的页面.因为,我们一          
  次可以打开好多标签页面来回切换着,始终只有一个页面在我们眼前,其他页面就是隐藏的,还有一种就是把浏览器最小化,所有的页面就都不可见

* API很简单,document.hidden就返回一个布尔值,如果true,表示页面可见,false则表示,页面隐藏.不同页面之间来回切换,触发

  Visibilitychange事件.还有一个dicument.VisibilityState,表示页面所处的状态,取值:visible,hidden等四个

  ```js

  document.addEcentListener("Visibilitychange",function(){
    if(document.hidden){
      document.title = "hidden";
    } else {
      document.title = "visible";
    }
  })
  ```

* 当我们打开这个页面,然后在打开另一个页面,来回点击这两个页面,当我们看到这个页面时,标题显示visible,当我们看另一个页面时,标题显示

  hidden;动画,视频,音频都可以在页面显示时打开,在页面隐藏是关闭

## 18.如何在页面上实现一个圆形的可点击区域？

共有三种方法:

1. map + area

```
<img src="t.jpg" width="1366" height="768" border="0" usemap="#Map" />  
<map name="Map" id="Map">  
 <area shape="circle" coords="821,289,68" href="www.baidu.com" target="_blank" />  
</map>

```
使用DW制作热点会变得非常的容易,最终会形成上面的代码

2. border-radius(H5)

```

<style>  
 .circle{  
/*圆设置*/
     width:100px;  
     height:100px;   
     border-radius: 50%;  
     cursor: pointer;
 /*文字设置*/
     position: absolute;  
     left:50px;  
     top:50px;    
     line-height: 100px;  
     text-align: center;  
     color: white;  
     background-color:dimgray;
 }  
</style>

```

3. 纯js实现

* 需要求一个点在不在圆上简单算法,获取鼠标坐标等等

  两点之间的距离计算公式

  ```
  ![Image of Yaktocat](./1.jpg)
  |AB|=Math.abs(Math.sqrt(Math.pow(X2-X1),2)+Math.pow(Y2-Y1,2)))
  Math.abs()求绝对值
  Math.pow(底数,指数)
  Math.sqrt()求平方根

  假设圆心为(100,100),半径为50,在圆内点击弹出相应的信息,在员外显示不在圆内的信息

  document.onclick = function(e){
    var r = 50;//圆的半径
    var x1 = 100,y1 = 100,x2 = e.clientX;
        y2 = e.clientY;
    var len = Math.abs(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,a)));
    if(len<=50){
      console.log("内")
    } else {
      console.log("外")
    }
  }
  ```

## 19.实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。

document有个属性conpatMode可以用来判断当前页面采用的何种渲染方式:

   BackCompat-Standards-compliant mode is not switched on.

   CSS1Compat-Standards-compliant monde is switched on.

 Quirksmode即怪异模式,而CSS1Compat是标准模式

 ```
 #line {
   width:1000px;
   height:1px;
   background-color:#3ecdb5;
 }
 <div id = "line"></div>
 ```

## 20.网页验证码是干嘛的，是为了解决什么安全问题？
* 是区分用户是计算机还是人的公共全自动程序
* 可以防止恶意破解密码,刷票,论坛灌水
* 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试
* 验证码是为了防止一些人使用软件恶意注册,发帖等行为而设的.
* 他的存在是为了确保登录网站的是一个坐在电脑面前的真人,而不是一个自动登录的软件

## 21.title与h1的区别、b与strong的区别、i与em的区别？

* title属性没有明确意义只表示是个标题;H1则表示层次明确的标题,对页面信息的抓取也有很大的影响;
* b是展示强调内容;strong是标明重点内容,有语气加强的含义,使用阅读设备阅读网络时:<strong>会重读
* i内容展示为斜体,em表示强调文本;
* Physical Style Elements -- 自然样式标签b, i, u, s;preSemantic Style Elements --

  语义样式标签strong, em,ins, del, code应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首

  选使用自然样式标签;

## 22.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？

* css盒子模型:有四个属性组成的外边距(margin),内边距(padding),边界(border),内容区(width和height)
* 不同:宽高不一样

  标准的css盒子模型宽高就是内容区宽高;

  低端IE css盒子模型宽高内边距 + 边界 + 内容区;

## 23.CSS选择符有哪些？哪些属性可以继承？

1. css选择符有哪些?

   类选择符(body),群组选择符(h1,h2,h3,span),包含选择符(h2,span),ID选择符(#id),class选择符(.content)

1. css选择器
   1. id选择器(#myid)
   2. 类选择器(.myclassname);
   3. 标签选择器(div,h1,p);
   4. 相邻选择器(h1 + p)
   5. 子选择器(ul>li)
   6. 后代选择器(li a)
   7. 通配符选择器( * )
   8. 属性选择器(a[rel = "external"])
   9. 伪类选择器(a:hover,li:nth-child)

1. 哪些标签可以继承

   class属性,伪类A标签,列表ul,li,dl,dd,dt可以继承

1. 哪些属性可以继承
   1. font-size
   2. font-fanmily
   3. color
   4. text-indent

1. 不可继承的样式
   1. border
   2. padding
   3. margin
   4. width
   5. height  

## 24.CSS优先级算法如何计算？

* 原则一:继承不如指定
* 原则二:#id > .class > 标签选择符
* 原则三:越具体越大
* 原则四:标签#id > #id;标签.class > .class

css优先级的计算规则如下:

* 元素标签中定义的样式(style属性),加1,0,0,0
* 每个ID选择符(如 #id),加0,1,0,0
* 每个class选择符(如 .class),每个属性选择符(如[attribute=])等,每个伪类(如 :hover)加0,0,1,0
* 每个元素选择符(如P)或伪元素选择符(如 :firstchild)等,加0,0,0,1

将这四个数字分别累加,就得到每个css定义的优先级的值,然后从左到右逐位比较大小,数字大的css样式的优先级就高

例子:

css文件或<style>中如下:

1. h1{color:red;} //一个元素选择符,结果是0,0,0,1
1. body h1{color:green;} //两个元素选择符,结果是0,0,0,2
1. h2.grape{color:purple;} //一个元素选择符,一个class选择符,结果0,0,1,1
1. li#answer{color:navy;} //一个元素选择符,一个ID选择符,结果是0,1,0,1
1. h1{color:blue;} //元素标签中定义,一个元素选择符,结果是1,0,0,1

### 补充

1. !important声明的样式优先级最高,如果冲突在进行计算
2. 如果优先级相同,则选择最后出现的样式
3. 继承得到的样式的优先级最低

## 25. CSS3新增伪类有那些？

* p:first-of-type 选择属于其父元素的首个<p>元素的每个<p>元素。
* p:last-of-type  选择属于其父元素的最后<p>元素的每个<p>元素。
* p:only-of-type  选择属于其父元素唯一的<p>元素的每个<p>元素。
* p:only-child    选择属于其父元素的唯一子元素的每个<p>元素。
* p:nth-child(2)  选择属于其父元素的第二个子元素的每个<p>元素。
* :enabled :disabled 控制表单控件的禁用状态。
* :checked        单选框或复选框被选中

## 26.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？

* div居中的几种方法
  1. body { text-align:center; } 缺点:body内所有内容一并居中
  2. .center { position:fixed;left:50%; } 缺点:需要设置position属性,网页复杂时容易扰乱页面布局,而且只是元素的起始位置居中
  3. .center { width:500px;margin:0 auto;} 缺点:需要设置div宽度
  4. .center { display:-webkit-flex;-webkit-justify-content:center;-webkit-align-items:center;} 缺点:需要支持html5
  5. .center { position:absolute;top:50%;left:50%;-ms-transform:translate(-50%,-50%);-moz-transform:translate(-50%,-50%)

     -o-transform:translate(-50%,-50%);transform:translate(-50%,-50%);} 缺点:需要支持html5

  6. .center { margin:auto;position:absolute;left:0;right:0;}
  7. .parent { ustify-content:center;align-items:center;display:_ webkit-flex; }

* 如何居中一个浮动元素?

1. 父元素和子元素同时做浮动,然后父元素相对左移动50%,然后子元素相对右移动50%,或者子元素相对左移动-50%
  ```
  html部分
  <div class="box">
    <p>浮动</p>
    <p>居中</p>
  </div>
  css部分:
  .box {
    float:left;
    position:relative;
    left:50%;
  }
  p {
    float:left;
    position:relative;
    right:50%;
  }
 ```


2. 父元素和子元素同时左浮动,然后父元素相对左移动50%,然后子元素相对左移动-50%
  
```
  <!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>页面浮动元素的水平居中</title>
<style type="text/css">
 .clearfix:after { content:""; height:0; visibility:hidden; display:block; clear:both; }
 .clearfix { zoom:1; }
 .wrap { margin:20px auto; padding:10px 0; background:orange; overflow:hidden; position:relative; }
 .inwrap{ float:left; position:relative; left:50%;}
 .page { float:left; position:relative; left:-50%; }
 .page li { float:left;margin:0 5px; }
 .page li a { display:block; padding:2px 9px; background:white; border:1px solid red; float:left;}
</style>
</head>
<body>
<div class="wrap clearfix">
 <div class="inwrap">
 <ul class="page">
  <li> <a href="#">上一页</a> </li>
  <li> <a href="#">1</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">4</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">4</a> </li>
  <li> <a href="#">5</a> </li>
  <li> <a href="#">6</a> </li>
  <li> <a href="#">下一页</a> </li>
 </ul>
 </div>
</div>
</body>
</html>

```

3. 也可以多套一层的方式设置left:-50%,可以避免一些不必要的ie bug.

```
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>页面元素的水平居中</title>
<style type="text/css">
 * { margin:0; padding:0; list-style:none; font-size:14px; }
 .clearfix:after { content:""; height:0; visibility:hidden; display:block; clear:both; }
 .clearfix { zoom:1; }
 a{ text-decoration:none;}
 h1{ text-align:center; padding:10px; font-size:20px; margin:30px 0;}
 .wrap { margin:20px auto; padding:10px 0; background:orange; overflow:hidden; position:relative; }
 .inwrap{ float:left; position:relative; left:50%;}
 .page { float:left; position:relative; left:-50%; }
 .page li { float:left;margin:0 5px; }
 .page li a { display:block; padding:2px 9px; background:white; border:1px solid red; float:left;}
</style>
</head>
<body>
<h1>页面元素的水平居中</h1>
<h2>浮动方式：</h2>
<div class="wrap clearfix">
 <div class="inwrap">
 <ul class="page">
  <li> <a href="#">上一页</a> </li>
  <li> <a href="#">1</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">4</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">2</a> </li>
  <li> <a href="#">3</a> </li>
  <li> <a href="#">4</a> </li>
  <li> <a href="#">5</a> </li>
  <li> <a href="#">6</a> </li>
  <li> <a href="#">下一页</a> </li>
 </ul>
 </div>
</div>
</body>
</html>
```
 

* 如何让绝对定位的div居中?

```
1. .element {
  width:600px;
  height:400px;
  position:absolute;
  left:50%;
  top:50%;
  margin-top:-200px; // 高度的一半
  margin-left:-300px; //宽度的一半
}
缺点:需要提前知道元素的尺寸,否则margin赋值的调整无法精确

2. .element {
  width:600px;
  height:400px;
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%); //50%为自身尺寸的一半
使用transform代替margin,transform中translate偏移的百分比值是相对于自身大小的
}

3. .element {
  width:600px;
  height:400px;
  position:absolute;
  left:0;
  top:0;
  right:0;
  bottom:0;
  margin:auto; //有了这个就自动居中了
}
关键在于:上下左右均0位置定位;然后margin:0;
```

## 26.display有哪些值？说明他们的作用。
```
|值                    |  描述                                                  |
|:-----------------------:|:------------------------------------------------------:|
|display:block;          | 此元素将显示为块级元素,此元素前后会带有换行符                 |
|display:compact;        | css中有值compact,不过由于缺乏广泛支持,已经从css2.1中删除     |
|display:inherit;        | 规定应该从父元素继承 display 属性的值。                     |
|display:inline;         | 默认。此元素会被显示为内联元素，元素前后没有换行符。            |
|display:inline-block;   | 行内块元素                                               |
|display:inline-table;   | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
|display:list-item;      | 此元素会作为列表显示。                                     |
|display:marker;         | CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。|
|display:none;           | 此元素不会被显示                                           |
|display:run-in;         | 此元素会根据上下文作为块级元素或内联元素显示。                 |
|display:table;          | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
|display:table-caption;  | 此元素会作为一个单元格列显示（类似 <col>）                    | 
|display:table-cell;     | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）            |
|display:table-column;   | 此元素会作为一个单元格列显示（类似 <col>）                    |
|display:table-column-group;  | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。  |
|display:table-footer-group;  | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。     |
|display:table-header-group;  | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。     |
|display:table-row;      |  此元素会作为一个表格行显示（类似 <tr>）。                    |
|display:table-row-group;  | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。        |
|display:!important;     | 　为了提升优先级                                           |
```

## 27.position的值relative和absolute定位原点是？
1. position:relative;如果对一个元素进行相对定位,首先它将出现在它所在的位置上,然后通过设置垂直或水平位置,让这个元素

  "相对与"它的原始起点进行移动.(注:相对定位时,无论是否进行移动,元素仍然占据原来的空间,因此移动元素会导致它覆盖其他框)

  相对定位:relative没有脱离正常的文档流,被设置元素相对于其原始位置而进行定位,其原始位置信息仍存在

2. position:absolute:表示绝对定位位置将依据浏览器左上角开始计算.绝对定位使元素脱离文档流,因此不占据空间.普通文档流

   中的元素的布局就像绝对定位的元素不存在时一样.(注:因为绝对定位的框与文档流无关,所以他们可以覆盖页面上的其他元素并可以通

   过z-index来控制它的层级次序.z-index的值越高,他显示的越在上层)

   绝对定位:ablution脱离了文档流与浮动模型,独立于其他对象而存在,没有占位

3. 父容器上使用相对定位,子元素使用绝对定位后,这样子元素的位置不再相对于浏览器左上角,而是相对于父窗口左上角


## 28.CSS3有哪些新特性？
1. CSS3的选择器
   1. E:last-child匹配父元素的最后一个子元素E
   2. E:nth-child(n)匹配父元素的第n个子元素E
   3. E:nth-last-child(n)css3匹配父元素的倒数第n个子元素E

2. @Font-face特性

   Font-face可以用来加载字体样式,而且它能够加载服务器端的字体文件,让客户端显示客户端没有安装的字体

   ```
   @font-face {
     font-family:BorderWeb;
     src:url(BORDERW0.eot);
   }
   @font-face {
     font-family:Runic;
     src:url(RUNICMT0.eot);
   }
   .border {
     FONT-SIZE:35px;
     color:black;
     font-family:"BorderWeb"
   }
   .eveny {
     FONT-SIZE:110px;
     color:black;
     font-family:"Runic"
   }
   淘宝字体:
   @font-face {  
               font-family: iconfont;  
               src: url(//at.alicdn.com/t/font_1465189805_4518812.eot);                
   }  
   ```  

3. 圆角 border-radius:15px;

4. 多列布局(multi-column layout)(注:兼容性不好,还不够成熟,还不能用在实际项目中)

```
<div class="mul-col">  
    <div>  
        <h3>新手上路</h3>  
        <p>新手专区 消费警示 交易安全 24小时在线帮助 免费开店</p>  
    </div>  
    <div>  
        <h3>付款方式</h3>  
        <p>快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款</p>  
    </div>  
    <div>  
        <h3>淘宝特色</h3>  
        <p>手机淘宝 旺信 大众评审 B格指南</p>  
    </div>  
</div>  

.mul-col{  
    column-count: 3;  
    column-gap: 5px;  
    column-rule: 1px solid gray;  
    border-radius: 5px;  
    border:1px solid gray;  
    padding: 10px   ;  
}  
```

5. 阴影(shadow)

   .class{text-shadow:5px 2px 6px rgba(64,64,64,0.5);}

6. css3的渐变效果

   .a { background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E));  }

   这里linear表示线性渐变,从左到右,由蓝色(#2A8BBE)到红色(#FE280E)的渐变

7. css弹性盒子模型

```
<div class="boxcontainer">  
    <div class="item">1</div>  
    <div class="item">2</div>  
    <div class="item">3</div>  
    <div class="item">4</div>  
</div>  
.boxcontainer {   
    width: 1000px;   
    display: -webkit-box;   
    display: -moz-box;   
    -webkit-box-orient: horizontal;   
    -moz-box-orient: horizontal;   
}   

 .item {   
    background: #357c96;   
    font-weight: bold;   
    margin: 2px;   
    padding: 20px;   
    color: #fff;   
    font-family: Arial, sans-serif;   
}  

```


8. css制作特效
    1. transition对象变换时的过渡效果(transition-property对象参与过渡的属性;transition-duration过渡的持续时间

       ;transition-timing-function过渡的类型; transition-delay延迟过渡的时间)

    2. transition 2D转换效果(主要包括transtion--水平移动; rotate--旋转; scale--伸缩; skew--倾斜)
    3. animation动画效果

## 30.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？

1. Flexbox:该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。这种布局方式在条目尺寸未知或动态时也能工作。
2. Flexbox:布局的主体思想是似的元素可以改变大小以适应可用空间,当可用空间变大,Flex元素将伸展大小以填充可用空间,当Flex元素超出可用空间时,当      Flex元素超出可用空间时将自动缩小么,总之Flex元素是可以让你的布局根据浏览器的大小进行自动伸缩
3. 主要思想:是让容器有能力来改变项目的宽度和高度,以填满可用空间(主要是为了容纳所有类型的显示设备和屏幕尺寸)的能力
4. 适用场景:自适应导航;常见3栏移动优先布局

## 31.用纯CSS创建一个三角形的原理是什么？
1. 采用的是均份原理:盒子都是一个矩形或正方形,从形状的中心,向4个角上下左右划分四个部分
2. 代码实现
   1. 保证元素是块级元素
   2. 设置元素的边框
   3. 不需要显示的边框使用透明色

```
.square {
  width:0;
  height:0;
  margin:0 auto;
  border:6px solid transparent;
  border-top:6px solid red;
}
第二种写法
.square {
  width:0;
  height:0;
  margin:0 auto;
  border-width:6px;
  border-color:red transparent transparent;
  border-style:solid dashed dashed dashed;//为了兼容IE6,把没有的边框都设置为虚线
}
```

## 32. 一个满屏 品 字布局 如何设计?

### 需要的技术
1. 元素水平居中对齐
   1. 使用margin对齐
   2. 使用left:50%
   3. 使用text-align:行内元素居中对齐,给父元素设置text-align:center
2. 元素对相对窗口定位
   1. 使用filxed:总是根据浏览器的窗口来进行元素的定位
   2. 使用html和body的width和height填充这个窗口
3. 元素左右定位
   1. 使用float左右浮动
   2. 使用绝对定位进行左右定位

```
第一种方式:
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>满屏品字布局</title>
    <style type="text/css">
        *{
            margin: 0;
            padding: 0;
        }

        html,body{
            height: 100%;/*此设置非常关键，因为默认的body，HTML高度为0，所以后面设置的div的高度无法用百分比显示*/
        }       

        .header{
            height:50%; /*此步结合html,body高度为100%，解决元素相对窗口的定位问题*/
            width: 50%;     
            background: #ccc;           
            margin:0 auto;
        }

        .main{
            width: 100%;
            height: 50%;
            background: #ddd;
        }

        .main .left,.main .right{
            float: left;/*采用float方式，对元素进行左右定位*/
            width:50%;/*此步解决元素相对窗口的定位问题*/
            height:100%;/*此步解决元素相对窗口的定位问题*/
            background: yellow;
        }

        .main .right{
            background: green;
        }
    </style>
</head>
<body>
<div class="header"></div>
<div class="main">
    <div class="left"></div>
    <div class="right"></div>
</div>
</body>
</html>

第二种方式：

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
    <title>满屏品字布局</title>
    <style type="text/css">
        body{  
          height: 1200px;  
      }  
      .main {  
          position: fixed;  /*此步解决元素相对窗口的定位问题*/
          left: 0;  
          top: 0;  
          height: 100%;  
          width: 100%;  
      }  
      .wrapper-up {  
          height: 50%;  
      }  

      .wrapper-down {  
          height: 50%;  
          position: relative;  
      }  
      .div-square-up {  
          width: 50%;  
          margin: 0 auto;  
          border: 2px solid red;  
          height: 96%;  
          box-sizing: border-box;  
      }  

      .div-square-left {  
          position: absolute;  /*此步解决元素左右定位问题*/
          left: 0;  
          width: 48%;  
          height: 100%;  
          box-sizing: border-box;  
          border: 2px solid red;  
      }  

      .div-square-right {  
          position: absolute;   /*此步解决元素左右定位问题*/
          right: 0;  
          width: 48%;  
          height: 100%;  
          border: 2px solid red;  
          box-sizing: border-box;  
      }  
    </style>
</head>
<body>
    <div class="main">  
         <div class="wrapper-up">  
           <div class="div-square-up"></div>  
         </div>  
         <div class="wrapper-down">  
           <div class="div-square-left"></div>  
           <div class="div-square-right"></div>  
         </div>  
    </div>
</body>
</html>
```

## 33.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？



## 34.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
1. 引起原因:浏览器的默认行为是把inline元素间的空白字符(空格换行tab)渲染成一个空格,<li>换行后会产生换行字符,而它会变成一个空格,空格就占用一个字符的宽度
2. 解决方案:
   1. 既然是因为<li>换行导致的,那就可以将<li>代码全部写在一排

      ```
      <div class="a">
      <h3>123</h3>
      <ul>
      <li class="b"></li><li class-"b1"></li><li class="b2"></li><li class="b3"></li>
      </ul>
      </div>

      ```
   2. 为了代码美观以及方便修改,很多时候不能将<li>全部写在一排,那么将<ul>内的字符尺寸直接设为0

      ```
      .a ul {
        font-size:0px;
      }

      ```
   3. 强制将间隔消除,

      ```
      .a url {
        letter-spancing:-5px;
      }

      ```

      问题:li内的字符间隔也被设置了,之后需要设置li内字符间隔

      ```
      .a ul li {
        letter-spancing:normal;
      }
      ```


## 35.为什么要初始化CSS样式?
1. 因为浏览器的兼容问题,不同浏览器对有些标签的默认值是不同的,如果没对CSS初始化往往会出现浏览器之间的页面显示差异
2. 初始化CSS样式主要是提高编码质量,如果不初始化整个页面昨晚很糟糕,重复的css样式很多.去掉标签的默认样式如:margin,padding对其他浏览器默认解析字体大小,字体设置

```
body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, p, blockquote, th, td {      
    padding:0;
    margin:0;
}

```

## 36.absolute的containing block计算方式跟正常流有什么不同？

## 37.CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？

1. 作用:当在表格元素中使用时,此值可删除一行或一列,但是它不会影响表格的布局.被行或列占据的空间会留给其他内容使用.如果此值被用在其他的元素上,会呈现为"hiden"
   1. 对于一般的元素,它的表现跟display:hidden是一样的
   2. 如果这个元素是table相关的元素,例如table行,table group,table列,table column group,它的表现却跟display:none一样,也就是说,他们占用的空间也会释放
2. 在不同浏览器下的区别
   1. 在谷歌浏览器里,使用collapse值和使用hidden值没有区别
   2. 在火狐,Opera和IE11里,使用collapse值的效果就如它的字面意思是:table的行会消失,它的下面一行会补充它的位置

## 38.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？

## 39.

## 40.CSS权重优先级是如何计算的？
1. 第一等:代表内联样式,如:style="",权值为1000px
2. 第二等:代表ID选择器,如#content,权值为0100
3. 第三等:代表类,伪类和属性选择器,如.content,权值为0001
4. 第四等:代表类型选择器和伪元素选择器,如div p,权值为0001
5. 通配符,子选择器,相邻选择器等的.如*,>,+,权值为0000
6. 继承的样式没有权值

## 41.请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式
1. 为什么浮动?

   浮动float最开始出现的意义是为了让文字环绕图片而已,但人们发现,如果想要三个块级元素并排显示,都给他们加个float来的会比较方便

2. 为什么清除浮动?
   1. 父盒子的margin受到影响,无法实现左右居中
   2. 我没有给父盒子设置高度,浮动后父盒子的高度没有被撑开,图片中撑开的高度是padding带来的效果;父元素内子元素浮动,便会出现上述情况,父元素的高度塌缩

3. 清除浮动的方式?
   1. 添加新的元素应用clear:both

      ```
      html:
      <div class="a">
      <div class="class1">1</div>
      <div class="class2">2</div>
      <div class="class3">3</div>
      <div class="class4">4</div>
      </div>

      css:
      .a {
        clear:both;
        height:0;
        line-height:0;
        font-size:0;
      }

      补充:使用空标签清除浮动
      <ul>
      <li></li>
      <li></li>
      <li></li>
      <br style="clear:both">
      </ul>
      ```
   2. 父级div定义overflow:auto(注意:是父级div也就是这里的div,outer)

      ```
      html:
      <div class="a over-flow">
      <div class="1">1</div>
      <div class="2">2</div>
      <div class="3">3</div>
      </div>

      css:
      .over-flow {
        overflow:auto;
        zoom:1;//是处理兼容性问题
      }

      补充:
      原理:使用overflow属性来清除浮动有一点需要注意,overflow属性共有三个属性值:hidden,auto,visible.我们可以使用hiddent和auto值来清除浮动,但不能使用visible值,如果使用这个值将无法达到清除效果,其他两个值都可以

      ```
   3. after方法,作用于父元素

       ```
       css:
       .a {
         zoom:1;
       }
       .a:after {
         clear:both;
         content:'';
         display:block;
         width:0;
         height:0;
         visibility:hidden;
       }
       ```

## 42.移动端的布局用过媒体查询吗？
1. 内联写法:and之后必须有空格

```
   @media screen and (min-width:960px //判断浏览器大小条件){
     body{background:red} //常规的样式  
   }

```

2. 外联写法:当满足屏幕满足条件的时候连接href后的css文件

```
<link='stylesheet' media='screen and (min-width:960)' href='xx.css'/>
<link='stylesheet' media='screen and (min-width:960) and (max-width:1960)' href='xx.css'/>

```

3. 媒体查询根据不同屏幕显示不同界面有两种方式:
   1. 在不同的媒体查询判定的大括号后写不同样式
   2. 写两个相同的HTML内部的内容,通过媒体查询判断界面后,显示一个,隐藏一个

## 43. 使用 CSS 预处理器吗？喜欢那个？

#### CSS的好处：

1. css无法递归定义

   css语法不支持递归定义的表达式,所以你没有办法用一个语句定义一个启发式的规则


   ```
   
   比如这样的需求:".w 后面跟着一个数字,这个数字代表着width为百分之多少"(bootstrap的栅格系统就包含12种相对父级宽度的类定义)

   css
   .w1 {width:1%}
   .w2 {width:2%}
   /**
   .w3
   ...
   ...
   .w99
   **/
   .w100 {width:100%}

   预编译css
   @maxnumber:100;
   .makeWidthRules(@number) when(@number <= @maxnumber){
     .w@{number}{
       width:1% * @number;
     }
     .makeWidthRules(@number + 1);
   }
   .makeWidthRules(1);
   ```
   
   
2. css的mixin式复用性支持不够

 ```
   使用纯CSS,我们可以抽象出一些常用的布局CSS属性组合,通过CSS的类组合来达成常见的mixin式复用
   <style>
    .tc { text-align: center; }
    .m { margin-left: auto; margin-right: auto; }
    .w50p { width: 50%; }
    .db { display: block; }
   </style>
   <div class="tc m w50p">
      <img class="db">
   </div>

   这个方案有几个问题：　　
　　一：页面重构时，需要频繁修改class name;
       这个问题在后端人员掌握着视图层的时候格外突出，前后端耗费很多沟通成本
   二：要约束上下文的时候非常无力
   　　比如“只有在ul下面的img.db允许是display:block”的规则，写成ul img.db {display:block;}就完全跑偏了——
　　　　它违背了你创建这个.db类时的本意，造成了代码的可续性和可维护性下降。如果你要改动规则，需要同时修改HTML和CSS，
　　　　也可能造成新的样式问题
   .btn-standout {
    @extend .btn;
    @extend .btn-block;

     @media (max-width: $screen-xs-max) {
        @include button-size(
           $padding-large-vertical,
           $padding-large-horizontal,
           $font-size-large,
           $line-height-large,
           $border-radius-large
       );
    }

    &.sell {
       @extend .btn-primary;
    }
   }
   ```
   
   
3. 预编译可缓解多浏览器兼容造成的冗余
   
   ```
   进入CSS3的时代，旧式CSS hack如filter，新式兼容前缀如-webkit等，都是冗余，修改的时候也需要修改多处，不容易维护
   对rgba背景的兼容

   .bg {
     filter: progid:DXImageTransform.Microsoft.gradient(startcolorstr=#ccff825b,endcolorstr=#ccff825b);
   }
   :root .bg{
     -ms-filter:none;
     background:rgba(255,130,91,0.8)
   }

   在LESS里面，写个函数就能解决，多次复用也不需要看到如此之多的hack：
   .rgbaBG(@c , @a){
    @rgba : rgba(red(@c),green(@c),blue(@c),@a);
    @shim : argb(@rgba) ;
    filter: ~"progid:DXImageTransform.Microsoft.gradient(startcolorstr=@{shim},endcolorstr=@{shim})" ;
    :root & {
        -ms-filter: none ;
        background: @rgba ;
      }
    }
    .bg {
        .rgbaBG(#ff825b, 0.8) ;
    }  

    此外，使用LESS时，可以很方便的使用base64 data uri的方案。不需要直接面临在CSS中已达陀字符
    .bg { background:data-uri('../data/image.jpg');}
    
   ```
   
   
   
   
   

#### 什么是css预处理器

CSS预处理器定义了一种新的语言，基本的思想是用一种专门的编程语言，开发者只需要使用这种语言进行编码工作，减少枯燥无味的CSS代码的编写过程的同时，
它能让你的CSS具备更加简洁、适应性更强、可读性更加、层级关系更加明显、更易于代码的维护等诸多好处。

CSS预处理器种类繁多，本次就以Sass、Less、Stylus进行比较。

